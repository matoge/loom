<!DOCTYPE html>
<html>
<head>
    <title>Working 3D Annotation Tool</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body { margin: 0; background: #1a1f2e; color: white; font-family: Arial; }
        canvas { width: 100%; height: 100vh; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; }
        button { padding: 10px 20px; margin: 5px; background: #ff6b35; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #ff5722; }
        select { padding: 8px; margin: 5px; background: #2a2f3e; color: white; border: 1px solid #444; border-radius: 4px; }
    </style>
</head>
<body>
    <div id="controls">
        <h3>üéØ 3D Annotation Tool</h3>
        <select id="preset">
            <option value="traffic_scene">üö¶ Traffic Scene</option>
            <option value="urban_street">üèôÔ∏è Urban Street</option>
            <option value="parking_lot">üÖøÔ∏è Parking Lot</option>
        </select>
        <button onclick="loadData()">LOAD POINTS</button>
        <div id="status">Ready</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        let scene, engine, camera, pointCloud;
        
        // Initialize Babylon.js
        const canvas = document.getElementById('canvas');
        engine = new BABYLON.Engine(canvas, true);
        scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.06, 0.08, 0.12);

        // Camera aligned with ISO 8855
        camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI/3, 25, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);

        // Lighting
        new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);

        // Ground
        const ground = BABYLON.MeshBuilder.CreateGround('ground', {width: 100, height: 100}, scene);
        const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
        ground.material = groundMat;

        // Grid system
        const lines = [];
        
        // Circles
        for (const r of [10, 20, 30, 50]) {
            const points = [];
            for (let i = 0; i <= 64; i++) {
                const a = (i / 64) * 2 * Math.PI;
                points.push(new BABYLON.Vector3(r * Math.cos(a), 0.05, r * Math.sin(a)));
            }
            lines.push(points);
        }
        
        // Radial lines
        for (const deg of [0, 45, 90, 135, 180, 225, 270, 315]) {
            const rad = deg * Math.PI / 180;
            lines.push([
                new BABYLON.Vector3(0, 0.05, 0),
                new BABYLON.Vector3(50 * Math.cos(rad), 0.05, 50 * Math.sin(rad))
            ]);
        }

        const grid = BABYLON.MeshBuilder.CreateLineSystem('grid', { lines }, scene);
        grid.color = new BABYLON.Color3(0.3, 0.4, 0.5);

        // Coordinate axes
        const axes = [
            // Z-axis (forward/back) - Red
            { line: [new BABYLON.Vector3(0, 0.1, -20), new BABYLON.Vector3(0, 0.1, 20)], color: new BABYLON.Color3(1, 0, 0) },
            // X-axis (left/right) - Green  
            { line: [new BABYLON.Vector3(-20, 0.1, 0), new BABYLON.Vector3(20, 0.1, 0)], color: new BABYLON.Color3(0, 1, 0) },
            // Y-axis (up) - Blue
            { line: [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 8, 0)], color: new BABYLON.Color3(0, 0, 1) }
        ];

        axes.forEach(axis => {
            const line = BABYLON.MeshBuilder.CreateLineSystem('axis', { lines: [axis.line] }, scene);
            line.color = axis.color;
        });

        // Start render loop
        engine.runRenderLoop(() => scene.render());
        window.addEventListener('resize', () => engine.resize());

        // Load point cloud data
        async function loadData() {
            try {
                document.getElementById('status').textContent = 'Loading...';
                
                const preset = document.getElementById('preset').value;
                const response = await fetch('http://localhost:8001/api/pointcloud/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ preset, num_points: 8000 })
                });

                if (!response.ok) throw new Error('API Error: ' + response.status);
                
                const data = await response.json();
                
                // Remove old points
                if (pointCloud) pointCloud.dispose();

                // Create new point cloud
                const pcs = new BABYLON.PointsCloudSystem('pcs', 1, scene);
                pcs.addPoints(data.points.length, (particle, i) => {
                    const [x, y, z, intensity] = data.points[i];
                    // ISO 8855 -> Babylon mapping: x->z, y->-x, z->y
                    particle.position = new BABYLON.Vector3(-y, z, x);
                    particle.color = new BABYLON.Color4(intensity, intensity*0.8, intensity*0.6, 1);
                });

                pcs.buildMeshAsync().then(() => {
                    pointCloud = pcs.mesh;
                    document.getElementById('status').textContent = `‚úÖ Loaded ${data.points.length} points`;
                });

            } catch (error) {
                document.getElementById('status').textContent = '‚ùå Error: ' + error.message;
            }
        }

        // Auto-load on start
        setTimeout(loadData, 1000);
    </script>
</body>
</html>